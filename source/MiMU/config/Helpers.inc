{$I Defines.inc}

type
  HVar = type helper for TVar
    function TArray(const aSize: Integer = 1): TArr; overload cdecl;
    function T2DArray(const size1D: Integer = 1; const size2D: Integer = 1): T2DArr; overload cdecl;
   {$IFDEF Integer}
      function ClampMin(const limit: Integer): Integer; cdecl;
      function ClampMax(const limit: Integer): Integer; cdecl;
      function Clamp(const minimum, maximum: Integer): Integer; overload; cdecl;
      function Clamp(const range: TRange): Integer; overload; cdecl;
      function BoundMin(const limit: Integer): Integer; cdecl;
      function BoundMax(const limit: Integer): Integer; cdecl;
      function Bound(const minimum, maximum: Integer): Integer; cdecl;
      function RestrictMin(const limit: Integer): Integer; cdecl;
      function RestrictMax(const limit: Integer): Integer; cdecl;
      function Restrict(const minimum, maximum: Integer): Integer; cdecl;
      function LimitMin(const limit: Integer): Integer; cdecl;
      function LimitMax(const limit: Integer): Integer; cdecl;
      function Limit(const minimum, maximum: Integer): Integer; cdecl;
      function ConstraintMin(const limit: Integer): Boolean; cdecl;
      function ConstraintMax(const limit: Integer): Boolean; cdecl;
      function Constraint(const minimum, maximum: Integer): Boolean; overload; cdecl;
      function Constraint(const range: TRange): Boolean; overload; cdecl;
      function Parity: Byte; cdecl; inline;
	  function Even: Boolean; cdecl; inline;
	  function IsEven: Boolean; cdecl; inline;
      function Odd: Boolean; cdecl; inline;
      function IsOdd: Boolean; cdecl; inline;
      function Increase(const N: Integer = 1): Integer; cdecl;
      function Decrease(const N: Integer = 1): Integer; cdecl;
      function Increment(const N: Integer = 1): Integer; cdecl;
      function Decrement(const N: Integer = 1): Integer; cdecl;
      function DigitCount: Integer; cdecl;
      function Digitz: TIntegerArray; cdecl;
      function Digits: TIntegerArray; cdecl;
      function NegA: Integer; cdecl; inline;
      function Neg: Integer; cdecl; inline;
      function Negative: Boolean; cdecl; inline;
      function Positive: Boolean; cdecl; inline;
      function Neutral: Boolean; cdecl; inline;
      function Compare(const target: Integer): Integer; cdecl; inline;
      function Distance(const T: Integer): Integer; cdecl; inline;
      function Difference(const T: Integer): Integer; cdecl; inline;
      function Opposite: Integer; cdecl; inline;
      function Sign: Integer; cdecl; inline;
      function Shuffle: Integer; cdecl;
	  function Over(const target: Integer): Boolean; cdecl; inline;
      function Under(const target: Integer): Boolean; cdecl; inline;
      function Oversize(const limit: Integer): Boolean; cdecl; inline;
      function Undersize(const limit: Integer): Boolean; cdecl; inline;
      function BitMax: Integer; cdecl;
      function Unbitify: TBooleanArray; overload; cdecl;
	  function Unbitify(const bCount: Integer): TBooleanArray; overload; cdecl;
    {$ENDIF}
    {$IFDEF Double}
      function ClampMin(const limit: Double): Double; cdecl;
      function ClampMax(const limit: Double): Double; cdecl;
      function Clamp(const minimum, maximum: Double): Double; cdecl;
	  function BoundMin(const limit: Double): Double; cdecl;
      function BoundMax(const limit: Double): Double; cdecl;
      function Bound(const minimum, maximum: Double): Double; cdecl;
      function RestrictMin(const limit: Double): Double; cdecl;
      function RestrictMax(const limit: Double): Double; cdecl;
      function Restrict(const minimum, maximum: Double): Double; cdecl;
      function LimitMin(const limit: Double): Double; cdecl;
      function LimitMax(const limit: Double): Double; cdecl;
      function Limit(const minimum, maximum: Double): Double; cdecl;
      function ConstraintMin(const limit: Double): Boolean; cdecl;
      function ConstraintMax(const limit: Double): Boolean; cdecl;
      function Constraint(const minimum, maximum: Double): Boolean; cdecl;
      function Increase(const N: Double = 1): Double; cdecl;
      function Decrease(const N: Double = 1): Double; cdecl;
      function Increment(const N: Double = 1): Double; cdecl;
      function Decrement(const N: Double = 1): Double; cdecl;
      function Digits: TIntegerArray; cdecl;
      function NegA: Double; cdecl; inline;
      function Neg: Double; cdecl; inline;
      function Negative: Boolean; cdecl; inline;
      function Positive: Boolean; cdecl; inline;
      function Neutral: Boolean; cdecl; inline;
      function MinDecimal: Double; cdecl;
      function MaxDecimal: Double; cdecl;
      function Accuracy(const a: Int32): Double; cdecl;
      function Compare(const target: Double): Int32; cdecl; inline;
      function Distance(const T: Double): Double; cdecl; inline;
      function Difference(const T: Double): Double; cdecl; inline;
      function Opposite: Double; cdecl; inline;
      function Sign: Int32; cdecl; inline;
      function FixDegrees: Double; cdecl;
      function Degrees: Double; cdecl;
      function FixRadians: Double; cdecl;
      function Radians(const compass: Boolean = False): Double; cdecl;
      function Percent(const position: Double): Double; cdecl; inline;
      function Percentage(const percent: Double): Double; cdecl; inline;
	  function Over(const target: Double): Boolean; cdecl; inline;
      function Under(const target: Double): Boolean; cdecl; inline;
      function Oversize(const limit: Double): Boolean; cdecl;
      function Undersize(const limit: Double): Boolean; cdecl;
    {$ENDIF}
    {$IFDEF string}
      function After(const s: string; const index: Integer = 1): string; overload;
      function After(const index: Integer; const count: Integer = 2147483647): string; overload;
      function Ahead(const s: string; const index: Integer = 2147483647): string; overload;
      function Ahead(const index: Integer; const count: Integer = 2147483647): string; overload;
      function Before(const s: string; const index: Integer = 1): string; overload;
      function Before(const index: Integer; const count: Integer = 2147483647): string; overload;
      function Behind(const s: string; const index: Integer = 2147483647): string; overload;
      function Behind(const index: Integer; const count: Integer = 2147483647): string; overload;
	  function Blank: Boolean; cdecl;
      function Amount(const s: string; const overlap: Boolean = True; const index: Integer = 2147483647): Integer; cdecl;
      function At(const s: string; const index: Integer = 1): Boolean; cdecl; inline;
      function Between(const s1, s2: string; const index: Integer = 1): string; cdecl;
      function Chars: TCharArray; cdecl;
      function Charify: TCharArray; cdecl;
      function Chop: TCharArray; cdecl;
      function Chunk(const a, b: Integer): string; cdecl;
      function Center(const size: Integer; const fill: Char = #32): string; cdecl;
      function Compare(const target: string): Integer; cdecl; inline;
      function Contains(const s: string; const index: Integer = 1): Boolean; cdecl;
      function Count(const s: string; const overlap: Boolean = True; const index: Integer = 1): Integer; cdecl;
      function Duplicate(const x: Integer = 2): string; cdecl;
      function Duplicated(const x: Integer; const glue: string): string; cdecl;
	  function Empty: Boolean; cdecl;
      function EndsWith(const s: string): Boolean; cdecl;
      function EndWith(const s: string; const index: Integer = 2147483647): Boolean; cdecl;
      function Exch(const aIndex, bIndex: Integer): Boolean; cdecl;
      function Exchange(const aIndex, bIndex: Integer): Boolean; cdecl;
      function Exists: Boolean; cdecl;
      function Explode: TCharArray; overload; cdecl;
	  function Explode(const d: string; const limit: Integer = -1): TStringArray; overload; cdecl;
      function Explode(const d: TStringArray; const limit: Integer = -1): TStringArray; overload; cdecl;
      function Find(const s: string; const index: Integer = 1): Integer; cdecl;
      function Flip: string; cdecl;
      function FromLeft(const count: Integer; const index: Integer = 1): string; cdecl;
      function FromRight(const count: Integer; const index: Integer = 2147483647): string; cdecl;
      function Get(const index: Integer; const count: Integer): string; cdecl; inline;
      function IDs: TIntegerArray; overload; cdecl;
      function IDs(const ID: TIntegerArray): TCharArray; overload; cdecl;
      function IDs(const ID: TIntegerArray; const item: Char): TCharArray; overload; cdecl;
      function IDs(const ID: TIntegerArray; const items: TCharArray): TCharArray; overload; cdecl;
      function Includes(const s: string; const index: Integer = 2147483647): Boolean; cdecl;
      function Loc(const s: string; const index: Integer = 2147483647): Integer; cdecl;
      function Location(const s: string; const index: Integer = 2147483647): Integer; cdecl;
      function Pick(const index: Integer; const count: Integer = 2147483647): string; cdecl;
      function Pos(const s: string; const index: Integer = 1): Integer; cdecl;
      function Position(const s: string; const index: Integer = 1): Integer; cdecl;
	  function Search(const s: string; const index: Integer = 1): Integer; cdecl;
      function PregQuote(const regex: string = '.\+*?[^]$(){}=!<>|:-'): string; cdecl;
      function Quotatation: string; cdecl;
	  function Reverse: Boolean; cdecl;  
      function Reversed: string; cdecl;
      function Slice(const a, b: Integer): string; cdecl;
      function StartsWith(const s: string): Boolean; cdecl;
      function StartWith(const s: string; const index: Integer = 1): Boolean; cdecl;
      function Stuff(const s: string; const iFrom, iCount: Integer): string; cdecl;
      function TrimLeft(const t: Char = #32): string; cdecl;
      function TrimRight(const t: Char = #32): string; cdecl;
      function Trim(const t: Char = #32): string; cdecl;
      function AsTRange: TRange; cdecl;
	  function Void: Boolean; cdecl;
	  function ToTRange(const glueRange: string = '..'; const openRange: Char = '['; const closeRange: Char = ']'): TRange; cdecl;
	  function IsBinary(const emptyTrue: Boolean = True): Boolean; cdecl;
	  function BoolifyBinary: TBooleanArray; cdecl;
      function MadeOf(const allowed: TCharArray): Boolean; cdecl;
	  function FreeOf(const forbidden: TCharArray): Boolean; cdecl;
      function BuiltWithout(const forbidden: TCharArray): Boolean; cdecl;
      function Consists(const allowed: TCharArray): Boolean; cdecl;
      function Pure(const allowed: TCharArray): Boolean; cdecl;
      function BuiltWith(const blocks: TCharArray): Boolean; cdecl;
    {$ENDIF}
    {$IFDEF Char}
      function Compare(const target: Char): Integer; cdecl; inline;
	  function Str(const size: Integer = 1): string; cdecl;
	  function ToStr(const size: Integer = 1): string; cdecl;
      function IsNumber: Boolean; cdecl;
      function IsNumeric: Boolean; cdecl;
      function IsLower: Boolean; cdecl;
      function IsUpper: Boolean; cdecl;
      function IsLowercase: Boolean; cdecl;
      function IsUppercase: Boolean; cdecl;
      function IsLetter: Boolean; cdecl;
      function Swapcase: Char; cdecl;
      function Upper: Char; cdecl;
      function Lower: Char; cdecl;
    {$ENDIF}
    {$IFDEF Boolean}
      function ToString: string; cdecl;
	  function Binary: Char; cdecl;
      function BinaryDigit: Integer; cdecl;
      function Bit: Integer; cdecl; inline;
	  function Bitify: Integer; cdecl;
      function ToInteger: Integer; cdecl;
      function AsInteger: Integer; cdecl;
      function Toggle: Boolean; cdecl;
      function Opposite: Boolean; cdecl;
      function Switch: Boolean; cdecl;
      function Flip: Boolean; cdecl;
      function Shuffle: Boolean; cdecl;
      function Select(const bTrue, bFalse: Integer): Integer; overload; cdecl;
      function Select(const bTrue, bFalse: Int64): Int64; overload; cdecl;
      function Select(const bTrue, bFalse: Double): Double; overload; cdecl;
      function Select(const bTrue, bFalse: string): string; overload; cdecl;
      function Select(const bTrue, bFalse: Char): Char; overload; cdecl;
      function Select(const bTrue, bFalse: Boolean): Boolean; overload; cdecl;
      function Select(const bTrue, bFalse: TPoint): TPoint; overload; cdecl;
      function Select(const bTrue, bFalse: TBox): TBox; overload; cdecl;
      function Select(const bTrue, bFalse: TRange): TRange; overload; cdecl;
      function Evaluate(const bTrue, bFalse: Integer): Integer; overload; cdecl;
      function Evaluate(const bTrue, bFalse: Int64): Int64; overload; cdecl;
      function Evaluate(const bTrue, bFalse: Double): Double; overload; cdecl;
      function Evaluate(const bTrue, bFalse: string): string; overload; cdecl;
      function Evaluate(const bTrue, bFalse: Char): Char; overload; cdecl;
      function Evaluate(const bTrue, bFalse: Boolean): Boolean; overload; cdecl;
      function Evaluate(const bTrue, bFalse: TPoint): TPoint; overload; cdecl;
      function Evaluate(const bTrue, bFalse: TBox): TBox; overload; cdecl;
      function Evaluate(const bTrue, bFalse: TRange): TRange; overload; cdecl;
      function Enable: Boolean; cdecl;
      function Disable: Boolean; cdecl;
      function SetFalse: Integer; cdecl;
      function SetTrue: Integer; cdecl;
      function SwitchOn(const state: Boolean): Boolean; cdecl;
      function SwitchOff(const state: Boolean): Boolean; cdecl;
    {$ENDIF}
    {$IFDEF TPoint}
      function Inside(const bx: TBox): Boolean; cdecl; inline;
	  function Clamp(const area: TBox): TPoint; cdecl;
      function Create: TPoint; overload; cdecl;
      function Grid(const rows, columns: Integer; const spaceVertical: Integer = 0; const spaceHorizontal: Integer = 0): TPointArray; cdecl;
      function Row(const cells: Integer; const space: Integer = 0): TPointArray; cdecl;
      function Column(const cells: Integer; const space: Integer = 0): TPointArray; cdecl;
    {$ENDIF}
    {$IFDEF TBox}
      function Create: TBox; overload; cdecl;
      function Inside(const targets: TBoxArray): Boolean; overload; cdecl;
      function Grid(const rows, columns: Integer; const spaceVertical: Integer = 0; const spaceHorizontal: Integer = 0): TBoxArray; cdecl;
      function Row(const cells: Integer; const space: Integer = 0): TBoxArray; cdecl;
      function Column(const cells: Integer; const space: Integer = 0): TBoxArray; cdecl;
    {$ENDIF}
    {$IFDEF TRange}
      function Create: TRange; overload; cdecl;
      function Distribute(const parts: Integer): TRangeArray; cdecl;
      function Partition(const size: Integer): TRangeArray; cdecl;
      function Divide(const size: Integer): TRangeArray; cdecl;
    {$ENDIF}
  end;
  HArr = type helper for TArr
    function Add(const item: TVar; const duplicates: Boolean = True): TArr; overload; cdecl;
    function Add(const items: TArr; const duplicates: Boolean = True): TArr; overload; cdecl;
    function AllEqual: Boolean; overload; cdecl;
    function AllSame: Boolean; overload; cdecl;
    function AllUnique: Boolean; overload; cdecl;
    function Any(const null: TVar): TVar; overload; cdecl;
    function Any: TVar; overload; cdecl;
    function Append(const item: TVar; const duplicates: Boolean = True): TArr; overload; cdecl;
    function Append(const items: TArr; const duplicates: Boolean = True): TArr; overload; cdecl;
	function Backwards: TArr; overload; cdecl;
    function Blend(const items: TArr; const index: Integer = 2147483647): TArr; overload; cdecl;
    function Build(const item: TVar; const aSize: Integer = 1): TArr; overload; cdecl;
	function BuiltWith(const blocks: TArr): Boolean; cdecl;
    function MadeOf(const allowed: TArr): Boolean; overload; cdecl;
    function FreeOf(const forbidden: TArr): Boolean; overload; cdecl;
    function BuiltWithout(const forbidden: TArr): Boolean; overload; cdecl;
    function Blit(const items: TArr; const index: Integer = 0): Integer; overload; cdecl;
    function Classes: T2DArr; overload; cdecl;
	function Classes(const weight: TIntegerArray): T2DArr; overload; cdecl;
	function Classes(const weight: TDoubleArray): T2DArr; overload; cdecl;
    function Classify: T2DArr; overload; cdecl;
	function Classify(const weight: TIntegerArray): T2DArr; overload; cdecl;
	function Classify(const weight: TDoubleArray): T2DArr; overload; cdecl;
    function Clear: Boolean; overload; cdecl;
    function Clone(const index: Integer = 0; const count: Integer = 2147483647): TArr; overload; cdecl;
    function Clone(const ID: TIntegerArray): TArr; overload; cdecl;
    function Combine(const b: TArr): TArr; overload; cdecl;
    function Compact: TArr; overload; cdecl;
    function Compacted: TArr; overload; cdecl;
    function Compress: TArr; overload; cdecl;
    function Compressed: TArr; overload; cdecl;
	function Comprised(const items: TArr): Boolean; overload; cdecl;
	function Constant(const item: TVar): Boolean; overload; cdecl;
	function Constant: Boolean; overload; cdecl;
    function Contains(const item: TVar; const index: Integer = 0): Boolean; cdecl;
    function Copy(const index: Integer = 0; const count: Integer = 2147483647): TArr; overload; cdecl;
    function Create(const item: TVar): TArr; overload; cdecl;
    function Create(const aSize: Integer; const item: TVar): TArr; overload; cdecl;
    function Delete(const index: Integer = 0): TArr; overload; cdecl;
    function Delete(const ID: TIntegerArray): TArr; overload; cdecl;
    function Differ(const target: TArr): Boolean; overload; cdecl;
    function Disordered: TArr; overload; cdecl;
	function Distribute(const parts: Integer): T2DArr; overload; cdecl;
	function Drop(const item: TVar; const eraseDuplicates: Boolean = True): TArr; overload; cdecl;
    function Dump(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function Dupe: TArr; overload; cdecl;
    function Duplicate(const xTimes: Integer = 1): TArr; overload; cdecl;
    function Elements(const returnIDs: TIntegerArray; const returnSort: Boolean = True): TArr; overload; cdecl;
    function Emplace(const item: TVar; const index: Integer = 0): Integer; overload; cdecl;
    function Empty: Boolean; overload; cdecl;
    function Equal(const target: TArr): Boolean; overload; cdecl;
    function Erase(const item: TVar; const index: Integer = 2147483647; const all: Boolean = True): TArr; overload; cdecl;
    function Erase(const item: TVar; const all: Boolean): TArr; overload; cdecl;
    function Erase(const items: TArr; const index: Integer = 2147483647; const all: Boolean = True): TArr; overload; cdecl;
    function Erase(const items: TArr; const all: Boolean): TArr; overload; cdecl;
	function Exact(const items: TArr): Boolean; overload; cdecl;
    function Excessive: Boolean; overload; cdecl; 
    function Exch(const aIndex, bIndex: Integer): Boolean; overload; cdecl;
    function Exchange(const aIndex, bIndex: Integer): Boolean; overload; cdecl;
	function Exchange(var b: TArr): Integer; overload; cdecl;
	function Exclude(const items: TArr; const index: Integer = 2147483647): TArr; overload; cdecl;
	function Exists: Boolean; overload; cdecl;
    function Extend(const item: TVar): TArr; overload; cdecl;
    function Extend(const items: TArr): TArr; overload; cdecl;
    function Extract(const item: TVar; const index: Integer = 0): TArr; overload; cdecl;
    function Extract(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function ExtractEvery(const X: Integer = 1; const index: Integer = 0): TArr; overload; cdecl;
    function ExtractIDs(const allowed: TIntegerArray): TArr; overload; cdecl;
    function ExtractIndexes(const allowed: TIntegerArray; const aSorted: Boolean = False): TArr; overload; cdecl;
    function Feed(const item: TVar; const allowDuplicates: Boolean = False): Integer; overload; cdecl;
	function Fill(const item: TVar; const index: Integer = 0; const count: Integer = 2147483647): TArr; overload; cdecl;
    function Fill(const items: TArr; const index: Integer = 0; const count: Integer = 2147483647): TArr; overload; cdecl;
    function Filter(const item: TVar; const index: Integer = 0): TArr; overload; cdecl;
    function Filter(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function FilterEvery(const X: Integer = 1; const index: Integer = 0): TArr; overload; cdecl;
    function FilterIDs(const forbidden: TIntegerArray): TArr; overload; cdecl;
    function FilterIndexes(const forbidden: TIntegerArray; const fSorted: Boolean = False): TArr; overload; cdecl;
    function Find(const ID: TRange; const item: TVar): Integer; overload; cdecl;
    function Find(const ID: TIntegerArray; const item: TVar): Integer; overload; cdecl;
    function Find(const ID: TRange; const items: TArr): Integer; overload; cdecl;
    function Find(const ID: TIntegerArray; const items: TArr): Integer; overload; cdecl;
	function First: Integer; overload; cdecl;
	function First(const item: TVar): Integer; overload; cdecl;
	function First(const items: TArr): Integer; overload; cdecl;
    function Fits(const maxValue: Integer): Boolean; overload; cdecl;
    function Fits(const target: TRange): Boolean; overload; cdecl;
    function Flip: Boolean; overload; cdecl;
    function Free: Integer; overload; cdecl;
    function FromLeft(const count: Integer; const index: Integer = 2147483647): TArr; overload; cdecl;
    function FromRight(const count: Integer; const index: Integer = 0): TArr; overload; cdecl;
    function Get: TArr; overload; cdecl;
    function Get(const ID: TIntegerArray): TArr; overload; cdecl;
    function Get(const ID: TRange): TArr; overload; cdecl;
    function Group: T2DArr; overload; cdecl;
    function Group(const weight: TIntegerArray; const wSorted: Boolean = False): T2DArr; overload; cdecl;
    function Group(const weight: TDoubleArray; const wSorted: Boolean = False): T2DArr; overload; cdecl;
    function Grow(const item: TVar; const allowDuplicates: Boolean = False): Integer; overload; cdecl;
    function Holds(const chain: TArr): Boolean; overload; cdecl;
	function Homogeneous(const item: TVar): Boolean; overload; cdecl;
	function Homogeneous: Boolean; overload; cdecl;
	function ID(const aAscending: Boolean = True): TIntegerArray; overload; cdecl;
    function IDs(const aAscending: Boolean = True): TIntegerArray; overload; cdecl;
    function IDs(const ID: TIntegerArray): TArr; overload; cdecl;
    function IDs(const ID: TIntegerArray; const item: TVar): TArr; overload; cdecl;
    function IDs(const ID: TIntegerArray; const items: TArr): TArr; overload; cdecl;
    function Includes(const item: TVar; const index: Integer = 2147483647): Boolean; cdecl;
	function Indexed(const aAscending: Boolean = True): TIntegerArray; overload; cdecl;
	function Indexes(const aAscending: Boolean = True): TIntegerArray; overload; cdecl;
	function Indices(const aAscending: Boolean = True): TIntegerArray; overload; cdecl;
    function Keep(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function Kill: Integer; overload; cdecl;
	function Last: Integer; overload; cdecl;
	function Last(const item: TVar): Integer; overload; cdecl;
	function Last(const items: TArr): Integer; overload; cdecl;
    function LeastCommon: TVar; overload; cdecl;
    function LeastFrequent: TVar; overload; cdecl;
    function Len: Integer; overload; cdecl;
    function Loc(const item: TVar; const index: Integer = 2147483647): Integer; overload; cdecl;
    function Loc(const items: TArr; const index: Integer = 2147483647): Integer; overload; cdecl;
    function Location(const item: TVar; const index: Integer = 2147483647): Integer; overload; cdecl;
    function Location(const items: TArr; const index: Integer = 2147483647): Integer; overload; cdecl;
    function Locations(const item: TVar; const index: Integer = 2147483647): TIntegerArray; overload; cdecl;
    function Locations(const items: TArr; const index: Integer = 2147483647): TIntegerArray; overload; cdecl;
	function Locations: TIntegerArray; overload; cdecl;
    function Mix(const mixings: Integer = 1): Boolean; overload; cdecl;
    function Mixed(const mixings: Integer = 1): TArr; overload; cdecl;
    function MostCommon: TVar; overload; cdecl;
    function MostFrequent: TVar; overload; cdecl;
    function Next(const index: Integer; const count: Integer = 2147483647): TArr; overload; cdecl;
	function Occurs(const item: TVar; const occurrence: Integer = 1): Boolean; overload; cdecl;
    function Overlay(const items: TArr; const index: Integer; const init: TVar): TArr; overload; cdecl;
    function Overlay(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function Oversize(const limit: Integer): Boolean; overload; cdecl;
    function Partition(const pSize: Integer): T2DArr; overload; cdecl;
    function Patch(const index: Integer; const items: TArr): Integer; overload; cdecl;
    function Pick(const items: TArr; const index: Integer = 0): TArr; overload; cdecl;
    function Pop: TVar; overload; cdecl;
    function Pop(const null: TVar): TVar; overload; cdecl;
    function Populate(const items: TArr; const times: Integer = 1): Boolean; overload; cdecl;
    function Populate(const item: TVar; const times: Integer = 1): Boolean; overload; cdecl;
    function Populated(const population: TRange): Boolean; overload; cdecl;
    function Populated(const populationMin: Integer = 1; const populationMax: Integer = 2147483647): Boolean; overload; cdecl;
    function Pos(const item: TVar; const index: Integer = 0): Integer; overload; cdecl;
    function Pos(const items: TArr; const index: Integer = 0): Integer; overload; cdecl;
    function Position(const item: TVar; const index: Integer = 0): Integer; overload; cdecl;
    function Position(const items: TArr; const index: Integer = 0): Integer; overload; cdecl;
    function Positions(const item: TVar; const index: Integer = 0): TIntegerArray; overload; cdecl;
    function Positions(const items: TArr; const index: Integer = 0): TIntegerArray; overload; cdecl;
	function Positions: TIntegerArray; overload; cdecl;
    function Presence(const item: TVar; const occurrence: Integer = 1): Boolean; overload; cdecl;
	function Previous(const index: Integer; const count: Integer = 2147483647): TArr; overload; cdecl;
    function Pull: TArr; overload; cdecl;
    function Push(const item: TVar): TArr; overload; cdecl;
    function Push(const items: TArr): TArr; overload; cdecl;
    function Put(const ID: TIntegerArray; const item: TVar): TArr; overload; cdecl;
    function Put(const ID: TIntegerArray; const items: TArr): TArr; overload; cdecl;
    function Put(const index: Integer; const items: TArr): TArr; overload; cdecl;
    function Randomized: TArr; overload; cdecl;
    function Range(const subArray: TArr; const index: Integer = 0): TRange; overload; cdecl;
    function Ranges(const subArray: TArr; const index: Integer = 0): TRangeArray; overload; cdecl;
    function Recreate(const arrSize: Integer): Boolean; overload; cdecl;
	function Reject(const items: TArr; const index: Integer = 2147483647): TArr; overload; cdecl;
    function Remove(const item: TVar; const index: Integer = 0; const all: Boolean = True): TArr; overload; cdecl;
    function Remove(const item: TVar; const all: Boolean): TArr; overload; cdecl;
    function Remove(const items: TArr; const index: Integer = 0; const all: Boolean = True): TArr; overload; cdecl;
    function Remove(const items: TArr; const all: Boolean): TArr; overload; cdecl;
	function Reposition(const oldIndex, newIndex: Integer): Boolean; overload; cdecl;
    function Reset: Integer; overload; cdecl;
    function Resize(const aChange: Integer): Integer; overload; cdecl;
    function Resize(const aChange: Integer; const null: TVar): Integer; overload; cdecl;
    function Reverse: Boolean; overload; cdecl;
    function Reversed: TArr; overload; cdecl;
    function Scan(const ID: TRange; const item: TVar; const limit: Integer = 2147483647): TIntegerArray; overload; cdecl;
    function Scan(const ID: TIntegerArray; const item: TVar; const limit: Integer = 2147483647): TIntegerArray; overload; cdecl;
    function Scan(const ID: TRange; const items: TArr; const limit: Integer = 2147483647): TIntegerArray; overload; cdecl;
    function Scan(const ID: TIntegerArray; const items: TArr; const limit: Integer = 2147483647): TIntegerArray; overload; cdecl;
    function Scramble(const swaps: Integer = -1): TArr; overload; cdecl;
	function Shake(const shakes: Integer = 1): TArr; overload; cdecl;
	function Shift: TVar; overload; cdecl;
    function Shift(const sCount: Integer): TArr; overload; cdecl;
	function Shuffle(const shuffles: Integer = 1): TArr; overload; cdecl;
    function Size: Integer; overload; cdecl;
    function Size(const aSize: Integer): TArr; overload; cdecl;
    function Size(const aSize: Integer; const null: TVar): TArr; overload; cdecl;
    function SizeBetween(const sMin, sMax: Integer): Boolean; overload; cdecl;
    function SizeMax(const target: Integer): Boolean; overload; cdecl;
    function SizeMin(const target: Integer): Boolean; overload; cdecl;
	function Slice(const r: TRange): TArr; overload; cdecl;
    function Slice(const r: TRangeArray): TArr; overload; cdecl;
    function Slots: TIntegerArray; overload; cdecl;
    function Some: TArr; overload; cdecl;
    function Some(const amount: Integer): TArr; overload; cdecl;
    function Span(const subArray: TArr; const index: Integer = 2147483647): TRange; overload; cdecl;
    function Spans(const subArray: TArr; const index: Integer = 2147483647): TRangeArray; overload; cdecl;
    function Strip(const item: TVar; const eraseDuplicates: Boolean = True): TArr; overload; cdecl;
    function SubarrayLocation(const pattern: TArr): Integer; overload; cdecl;
    function SubarrayLocations(const pattern: TArr): TIntegerArray; overload; cdecl;
    function SubarrayPosition(const pattern: TArr): Integer; overload; cdecl;
    function SubarrayPositions(const pattern: TArr): TIntegerArray; overload; cdecl;
    function Subset(const items: TArr): Boolean; overload; cdecl;
    function Supply(const item: TVar): Integer; overload; cdecl;
    function Supply(const items: TArr): Integer; overload; cdecl;
    function ToIndexes: TIntegerArray; overload; cdecl;
    function Trade(var b: TArr): Integer; overload; cdecl;
    function Undersize(const limit: Integer): Boolean; overload; cdecl;
    function Unduplicate: TArr; overload; cdecl;
	function Uniform: Boolean; overload; cdecl;
	function Uniform(const item: TVar): Boolean; overload; cdecl;
    function Unique: TArr; overload; cdecl;
    function Uniqued: TArr; overload; cdecl;
    function Uniques: TIntegerArray; overload; cdecl;
    function Unshift(const item: TVar): TArr; overload; cdecl;
    function Unshift(const items: TArr): TArr; overload; cdecl;
	function Void: Boolean; overload; cdecl;
    function Waste: Integer; overload; cdecl;
    {$IFDEF Sortable}
      function Sorted(const aAscending: Boolean = True): Boolean; overload; cdecl;
      function InOrder(const aAscending: Boolean = True): Boolean; overload; cdecl;
      function Orderly: Boolean; overload; cdecl;
      function Descend: TArr; overload; cdecl;
      function Ascend: TArr; overload; cdecl;
      function Descending: Boolean; overload; cdecl;
      function Ascending: Boolean; overload; cdecl;
      function Decreasing: Boolean; overload; cdecl;
      function Increasing: Boolean; overload; cdecl;
	  function Downward: Boolean; overload; cdecl;
      function Upward: Boolean; overload; cdecl;
      function Lowest: TVar; overload; cdecl;
      function Highest: TVar; overload; cdecl;
      function Mini(const aAscending: Boolean = True; const start: Integer = -1): Integer; overload; cdecl;
      function Mini(const start: Integer; const aAscending: Boolean = True): Integer; overload; cdecl;
      function Maxi(const aAscending: Boolean = True; const start: Integer = -1): Integer; overload; cdecl;
      function Maxi(const start: Integer; const aAscending: Boolean = True): Integer; overload; cdecl;
      function Mode: TVar; overload; cdecl;
      function Center: TVar; overload; cdecl;
      function BubbleSort(const aAscending: Boolean = True): Integer; overload; cdecl;
	  function BubbleSortOptimized(const aAscending: Boolean = True): Integer; overload; cdecl;
	  function QuickSorted(const aAscending: Boolean = True): TArr; overload; cdecl;
      function Uniq(const sSorted: Boolean = False): TArr; overload; cdecl;
    {$ENDIF}
    function QuickSorted(const weight: TIntegerArray; const aAscending: Boolean = True): TArr; overload; cdecl;
	function QuickSorted(const weight: TDoubleArray; const aAscending: Boolean = True): TArr; overload; cdecl;
    {$IFDEF Integer}
      function Bounds: TRange; overload; cdecl;
      function Bounds(var aSize: Integer): TRange; overload; cdecl;
	  function BoundingRange: TRange; cdecl;
      function Boundaries: TRange; cdecl;
      function Range: TRange; cdecl;
	  function Coverage: TRange; cdecl;
	  function MinMax: TRange; cdecl;
      function Region: TRange; overload; cdecl;
	  function Extent: TRange; cdecl;
      function Undupe: TIntegerArray; cdecl;
      function Unduped: TIntegerArray; cdecl;
      function Numberline: TIntegerArray; cdecl;
      function Sum: Int64; cdecl;
      function Density: Double; cdecl;
      function Mean: Double; cdecl;
      function Median: Double; cdecl;
      function Middle: Double; cdecl;
      function MostFreq(const null: Integer = -2147483648): Integer; cdecl;
      function LeastFreq(const null: Integer = -2147483648): Integer; cdecl;
      function BubbleSort2(const aAscending: Boolean = True): Integer; cdecl;
      function QuickSort(const aAscending: Boolean = True): Integer; cdecl;
      function QuickSort3W(const aAscending: Boolean = True): Integer; cdecl;
      function QSort(const aAscending: Boolean = True): Integer; cdecl;
      function CoctailSort(const aAscending: Boolean = True): Integer; cdecl;
      function CoctailSort2(const aAscending: Boolean = True): Integer; cdecl;
      function CombSort(const aAscending: Boolean = True): Integer; cdecl;
      function GnomeSort(const aAscending: Boolean = True): Integer; cdecl;
      function GnomeSortOptimized(const aAscending: Boolean = True): Integer; cdecl;
      function HeapSort(const aAscending: Boolean = True): Integer; cdecl;
      function InsertionSort(const aAscending: Boolean = True): Integer; cdecl;
      function SelectionSort(const aAscending: Boolean = True): Integer; cdecl;
      function SelectionSortBidirectional(const aAscending: Boolean = True): Integer; cdecl;
      function SelectionSortBidirectional2(const aAscending: Boolean = True): Integer; cdecl;
      function PancakeSort(const aAscending: Boolean = True): Integer; cdecl;
      function MergeSort(const aAscending: Boolean = True): Integer; cdecl;
      function MergeSortBU(const aAscending: Boolean = True): Integer; cdecl;
      function ShellSort(const aAscending: Boolean = True): Integer; cdecl;
	  function RadixSort(const aAscending: Boolean = True): Integer; cdecl;
      function Split(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Split(const diff: Integer): T2DIntegerArray; overload; cdecl;
      function Sblit(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Sblit(const diff: Integer): T2DIntegerArray; overload; cdecl;
	  function Groups(const aSorted: Boolean = False): T2DIntegerArray; overload; cdecl;
      function Group(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Group(const diff: Integer): T2DIntegerArray; overload; cdecl;
      function Groub(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Groub(const diff: Integer): T2DIntegerArray; overload; cdecl;
	  function Clique(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Clique(const diff: Integer): T2DIntegerArray; overload; cdecl;
	  function Knit(const minDiff, maxDiff: Integer): T2DIntegerArray; overload; cdecl;
      function Knit(const diff: Integer): T2DIntegerArray; overload; cdecl;
      function Invert: TIntegerArray; cdecl;
      function Inverted(const arrBounds: TRange): TIntegerArray; overload; cdecl;
      function Inverted: TIntegerArray; overload; cdecl;
      function Inverse(const arrBounds: TRange): TIntegerArray; overload; cdecl;
      function Inverse: TIntegerArray; overload; cdecl;
	  function Mirror: Boolean; cdecl;
	  function MinVal: Integer; overload; cdecl;
	  function MaxVal: Integer; overload; cdecl;
	  function Minimum(var index: Integer): Integer; overload; cdecl;
	  function Minimum: Integer; overload; cdecl;
	  function Maximum(var index: Integer): Integer; overload; cdecl;
	  function Maximum: Integer; overload; cdecl;
      function Pure(const allowed: TIntegerArray): Boolean; cdecl;
      function NoneOf(const forbidden: TIntegerArray): Boolean; cdecl;
      function AnyOf(const candidates: TIntegerArray): Boolean; cdecl;
      function AllOf(const candidates: TIntegerArray): Boolean; cdecl;
	  function Reinit: Integer; overload; cdecl;
      function Charify: TCharArray; overload; cdecl;
      function Charify(var str: string): TCharArray; overload; cdecl;
      function Stringify: string; overload; cdecl;
      function Stringify(var chars: TCharArray): string; overload; cdecl;
      function Special: Boolean; cdecl;
      function ExtractEven: TIntegerArray; overload; cdecl;
      function FilterEven: TIntegerArray; overload; cdecl;
      function ExtractOdd: TIntegerArray; overload; cdecl;
      function FilterOdd: TIntegerArray; overload; cdecl;
      function BSort(const aAscending: Boolean = True): Integer; cdecl;
      function BinarySort(const aAscending: Boolean = True): Integer; cdecl;
      function BinarySorted(const aAscending: Boolean = True): TIntegerArray; cdecl;
      function BinaryBoundL(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryBoundR(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryPosL(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryPosR(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinarySearch(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryContains(const x: Integer; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryCount(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryLocate(const x: Integer; const aAscending: Boolean = True): TRange; cdecl;
      function BinaryLocation(const x: Integer; const aAscending: Boolean = True): TRange; cdecl;
      function BinaryAppend(const x: Integer; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryAdd(const x: Integer; const aAscending: Boolean = True): TIntegerArray; cdecl;
      function BinarySearchF(const x: TRange; const aAscending: Boolean = True): Integer; cdecl;
      function BinarySearchL(const x: TRange; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryUnique(const aAscending: Boolean = True): Integer; cdecl;
      function BinaryUniqued(const aAscending: Boolean = True): TIntegerArray; cdecl;
      function BinaryUndupe(const aAscending: Boolean = True): TIntegerArray; cdecl;
      function BinaryGrow(const x: Integer; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryShrink(const x: Integer; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryLowerBound(const x: Integer; const aAscending: Boolean): Integer; overload; cdecl;
      function BinaryUpperBound(const x: Integer; const aAscending: Boolean): Integer; overload; cdecl;
      function BinaryRange(const x: TRange; const aAscending: Boolean = True): TRange; overload; cdecl;
      function BinaryRange(const x: Integer; const aAscending: Boolean = True): TRange; overload; cdecl;
    {$ENDIF}
    {$IFDEF Double}
      function BSort(const aAscending: Boolean = True): Integer; cdecl;
      function BinarySort(const aAscending: Boolean = True): Integer; cdecl;
      function BinarySorted(const aAscending: Boolean = True): TDoubleArray; cdecl;
      function BinaryBoundL(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryBoundR(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryPosL(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryPosR(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinarySearch(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryContains(const x: Double; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryCount(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryLocate(const x: Double; const aAscending: Boolean = True): TRange; cdecl;
      function BinaryLocation(const x: Double; const aAscending: Boolean = True): TRange; cdecl;
      function BinaryAppend(const x: Double; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryAdd(const x: Double; const aAscending: Boolean = True): TDoubleArray; cdecl;
      function BinarySearchF(const x: TRange; const aAscending: Boolean = True): Integer; cdecl;
      function BinarySearchL(const x: TRange; const aAscending: Boolean = True): Integer; cdecl;
      function BinaryUnique(const aAscending: Boolean = True): Integer; cdecl;
      function BinaryUniqued(const aAscending: Boolean = True): TDoubleArray; cdecl;
      function BinaryUndupe(const aAscending: Boolean = True): TDoubleArray; cdecl;
      function BinaryGrow(const x: Double; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryShrink(const x: Double; const aAscending: Boolean = True): Boolean; cdecl;
      function BinaryLowerBound(const x: Double; const aAscending: Boolean): Integer; overload; cdecl;
      function BinaryUpperBound(const x: Double; const aAscending: Boolean): Integer; overload; cdecl;
      function BinaryRange(const x: TRange; const aAscending: Boolean = True): TRange; overload; cdecl;
      function BinaryRange(const x: Double; const aAscending: Boolean = True): TRange; overload; cdecl;
      function Reinit: Integer; overload; cdecl;
    {$ENDIF}
    {$IFDEF string}
      function Span: Integer; cdecl;
      function Concat: string; cdecl;
      function Concatenate: string; cdecl;
      function Flatten: string; cdecl;
      function Glue: string; cdecl;
    {$ENDIF}
    {$IFDEF Char}
      function Str: string; cdecl;
      function ToStr: string; cdecl;
      function Join: string; overload; cdecl;
      function Join(const glue: string): string; overload; cdecl;
      function Stringify: string; overload; cdecl;
      function Stringify(const glue: string): string; overload; cdecl;
      function Ordinals: TIntegerArray; cdecl;
      function Unduped: TCharArray; cdecl;
      function TSA: TStringArray; cdecl;
    {$ENDIF}
	{$IFDEF Boolean}
      function Select(const sTrue, sFalse: Integer): TIntegerArray; overload; cdecl;
	  function Select(const sTrue, sFalse: Double): TDoubleArray; overload; cdecl;
	  function Select(const sTrue, sFalse: string): TStringArray; overload; cdecl;
	  function Select(const sTrue, sFalse: Char): TCharArray; overload; cdecl;
	  function Select(const sTrue, sFalse: Boolean): TBooleanArray; overload; cdecl;
	  function Select(const sTrue, sFalse: TPoint): TPointArray; overload; cdecl;
	  function Select(const sTrue, sFalse: TBox): TBoxArray; overload; cdecl;
	  function Select(const sTrue, sFalse: TRange): TRangeArray; overload; cdecl;
      function Bits: Integer; cdecl;
	  function Bitify: Integer; cdecl;
      function ToBits: Integer; cdecl;
      function Digits: TIntegerArray; overload; cdecl;
	  function Falsed: Boolean; overload; cdecl;
	  function Falseless: Boolean; overload; cdecl;
	  function Falseless(const maxFalse: Integer): Boolean; overload; cdecl;
	  function Falseness: Integer; overload; cdecl;
	  function Falses: TIntegerArray; overload; cdecl;
	  function Falsesome: Boolean; overload; cdecl;
	  function Falsesome(const minFalse: Integer): Boolean; overload; cdecl;
      function Str(const separator: string; const strTrue: string = 'True'; strFalse: string = 'False'): string; overload; cdecl;
      function Str: string; overload; cdecl;
      function Text(const strTrue, strFalse, separator: string): string; overload; cdecl;
      function Text(const strTrue: string = 'True'; strFalse: string = 'False'): string; overload; cdecl;
      function TIA(const valTrue: Integer = 1; const valFalse: Integer = 0): TIntegerArray; overload; cdecl;
	  function Toggle: TBooleanArray; overload; cdecl;
	  function Trued: Boolean; overload; cdecl;
	  function Trueless: Boolean; overload; cdecl;
	  function Trueless(const maxTrue: Integer): Boolean; overload; cdecl;
	  function Trueness: Integer; overload; cdecl;
	  function Trues: TIntegerArray; overload; cdecl;
	  function Truesome: Boolean; overload; cdecl;
	  function Truesome(const minTrue: Integer): Boolean; overload; cdecl;
	  function Opposite: TBooleanArray; overload; cdecl;
	  function BinaryStr: string; cdecl;
	  function BinaryDigits: TIntegerArray; cdecl;
	  function Binary: string; cdecl;
      function Reinit: Integer; overload; cdecl;
	{$ENDIF}
    {$IFDEF TPoint}
      function Bounds: TBox; overload; cdecl;
      function Bounds(var width, height: Integer): TBox; overload; cdecl;
	  function BoundingBox: TBox; cdecl;
      function Boundaries: TBox; cdecl;
	  function Box: TBox; cdecl;
      function Boxed: TBox; cdecl;
	  function MinMax: TBox; cdecl;
      function Region: TBox; overload; cdecl;
      function Coverage: TBox; overload; cdecl;
      function Undupe: TPointArray; cdecl;
      function Unduped: TPointArray; cdecl;
      function Invert: TPointArray; cdecl;
      function Inverted(const arrBounds: TBox): TPointArray; overload; cdecl;
	  function Inverted: TPointArray; overload; cdecl;
      function Inverse(const arrBounds: TBox): TPointArray; overload; cdecl;
	  function Inverse: TPointArray; overload; cdecl;
      function Edge(const scan8W: Boolean = False): TPointArray; cdecl;
      function FloodFill(const start: TPoint; const area: TBox; const scan8W: Boolean = False): TPointArray; overload; cdecl;
      function FloodFill(const start: TPoint; const scan8W: Boolean = False): TPointArray; overload; cdecl;
	  function Xs: TIntegerArray; overload; cdecl;
	  function Ys: TIntegerArray; overload; cdecl;
	  function XValues: TIntegerArray; overload; cdecl;
	  function YValues: TIntegerArray; overload; cdecl;
	  function Unzip(var xArr, yArr: TIntegerArray): Integer; cdecl;
	  function Zip(const xArr, yArr: TIntegerArray): Integer; cdecl;
	  function Extent: TBox; cdecl;
	  function Vertical: TRange; overload; cdecl;
	  function Horizontal: TRange; overload; cdecl;
      function Split(const xRadius, yRadius: Double): T2DPointArray; overload; cdecl;
      function Split(const radius: Double): T2DPointArray; overload; cdecl;
      function Segment(const radius: Double): T2DPointArray; overload; cdecl;
      function Fragment(const radius: Double): T2DPointArray; overload; cdecl;
      function Clusterize(const radius: Double): T2DPointArray; overload; cdecl;
      function Clusterize(const xRadius, yRadius: Double): T2DPointArray; overload; cdecl;
      function XClassify(const pSorted: Boolean = False): T2DPointArray; overload; cdecl;
      function YClassify(const pSorted: Boolean = False): T2DPointArray; overload; cdecl;
      function Reinit: Integer; overload; cdecl;
    {$ENDIF}
    {$IFDEF TBox}
      function X1s: TIntegerArray; overload; cdecl;
      function X2s: TIntegerArray; overload; cdecl;
      function Y1s: TIntegerArray; overload; cdecl;
      function Y2s: TIntegerArray; overload; cdecl;
      function X1Values: TIntegerArray; overload; cdecl;
      function X2Values: TIntegerArray; overload; cdecl;
      function Y1Values: TIntegerArray; overload; cdecl;
      function Y2Values: TIntegerArray; overload; cdecl;
      function Unzip(var x1Arr, y1Arr, x2Arr, y2Arr: TIntegerArray): Integer; cdecl;
      function Zip(const x1Arr, y1Arr, x2Arr, y2Arr: TIntegerArray): Integer; cdecl;
    {$ENDIF}	
    {$IFDEF TRange}
	  function Bounds: TRange; overload; cdecl;
	  function Range: TRange; overload; cdecl;
      function TIA: TIntegerArray; cdecl;
      function T2DIA: T2DIntegerArray; cdecl;
	  function Starting: TIntegerArray; overload; cdecl;
	  function Stopping: TIntegerArray; overload; cdecl;
	  function Normalized: TRangeArray; overload; cdecl;
	  function Gaps: TRangeArray; overload; cdecl;
      function Starts: TIntegerArray; overload; cdecl;
      function Stops: TIntegerArray; overload; cdecl;
      function StartValues: TIntegerArray; overload; cdecl;
      function StopValues: TIntegerArray; overload; cdecl;
      function Unzip(var startArr, stopArr: TIntegerArray): Integer; cdecl;
      function Zip(const startArr, stopArr: TIntegerArray): Integer; cdecl;
    {$ENDIF}
    {$IFDEF TSegment}
    {$ENDIF}
    {$IFDEF TCircle}
    {$ENDIF}
    {$IFDEF TTriangle}
    {$ENDIF}	
    end;
  H2DArr = type helper for T2DArr
    function Blank: Boolean; overload; cdecl;
    function Empty: Boolean; overload; cdecl;
	function Flat: TArr; overload; cdecl;
	function Flatten: TArr; overload; cdecl;
	function Irregular: Boolean; overload; cdecl;
	function Jagged: Boolean; overload; cdecl;
    function Merge: TArr; overload; cdecl;
	function Ragged: Boolean; overload; cdecl;
	function Size(var lengths: TIntegerArray): Int64; overload; cdecl;
    function Size: Int64; overload; cdecl;
	function Total: Int64; overload; cdecl;
	function Population: Int64; overload; cdecl;
	function Census: Int64; overload; cdecl;
    function Inventory(var items: TArr): Int64; overload; cdecl;
    function Inventory: Int64; overload; cdecl;
	function TArray: TArr; overload; cdecl;
    function Kill: Integer; overload; cdecl;
    function Kill(const k2D: TIntegerArray): Int64; overload; cdecl;
    function Free: Int64; overload; cdecl;
    function Recreate(const arrSize: Integer): Boolean; overload; cdecl;
    function Reset: Int64; overload; cdecl;
    function Destroy: Int64; overload; cdecl;
    function Pull: T2DArr; overload; cdecl;
  end;